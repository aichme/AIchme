{"description": "Wrong memory orderings inside the RwLock implementation allow for two writers to acquire the lock at the same time. The drop implementation used Ordering::Relaxed, which allows the compiler or CPU to reorder a mutable access on the locked data after the lock has been yielded.\n\nOnly users of the RwLock implementation are affected. Users of Once (including users of lazy_static with the spin_no_std feature enabled) are NOT affected.\n\nOn strongly ordered CPU architectures like x86, the only real way that this would lead to a memory corruption is if the compiler reorders an access after the lock is yielded, which is possible but in practice unlikely. It is a more serious issue on weakly ordered architectures such as ARM which, except in the presence of certain instructions, allow the hardware to decide which accesses are seen at what times. Therefore on an ARM system it is likely that using the wrong memory ordering would result in a memory corruption, even if the compiler itself doesn't reorder the memory accesses in a buggy way.", "methods": ["Incorrectly implemented synchronization primitives (RwLock) in a library or framework.", "Incorrect use of memory ordering (Ordering::Relaxed) in a library or framework.", "Memory corruption due to incorrect memory ordering on weakly ordered CPU architectures (ARM).", "Potential for data corruption on weakly ordered CPU architectures (ARM)."]}