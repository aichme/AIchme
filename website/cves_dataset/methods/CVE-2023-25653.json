{"description": "### Description\n\nWhen using the non-default \"fallback\" crypto back-end, ECC operations in `node-jose` can trigger a Denial-of-Service (DoS) condition, due to a possible infinite loop in an internal calculation.  For some ECC operations, this condition is triggered randomly; for others, it can be triggered by malicious input.\n\n#### Technical summary\n\nThe JOSE logic implemented by `node-jose` usually relies on an external cryptographic library for the underlying cryptographic primitives that JOSE operations require.  When WebCrypto or the Node `crypto` module are available, they are used.  When neither of these libraries is available, `node-jose` includes its own \"fallback\" implementations of some algorithms based on `node-forge`, in particular implementations of ECDH and ECDSA. \n\nA various points, these algorithm implementations need to compute to the X coordinate of an elliptic curve point.  This is done by calling the `getX()` method of the object representing the point, which is an alias of the function `pointFpGetX()` in `lib/deps/ecc/math.js`.\n\nComputing the X coordinate from the form in which the point is stored requires computing the modular inverse of the Z coordinate, using the `modInverse` function from the `jsbn` library (e.g., `this.z.modInverse(this.curve.p)`).  The output of this function call is multiplied by another value before being reduced with the `barrettReduce()` function.\n\nThe root cause of this issue is that the `jsbn` `modInverse` function sometimes returns negative results.  These results are correct in that they are equivalent mod the relevant modulus, but can be problematic for functions that expect modular operations to always return positive results (in the range `[0, p)`, where `p` is the modulus).\n\nIn particular, while the Barrett reduction algorithm in general can handle negative inputs, the implementation in `node-jose` explicitly does not. Therefore, while the negative value that is returned by `modInverse()` is mathematically correct, it leads to an error in `barrettReduce()` causing an infinite loop which may result in a Denial of Service condition.\n\nFor a given prime modulus, we estimate that roughly one in every `2^20` inputs produce a negative `modInverse()`.  This estimate was validated with exhaustive testing on small primes (<30 bits) and randomized testing with regard to the P-256 prime.\n\n### Impact\n\nThis issue is only present in situations where the \"fallback\" cryptographic implementation is being used, i.e., situations where neither WebCrypto nor the Node `crypto` module is available.\n\nThe following elliptic curve algorithms are impacted by this issue (all in `lib/deps/ecc/index.js`):\n\n- Elliptic curve key generation (`exports.generateKeyPair`)\n- Converting an elliptic curve private key to a public key (`ECPrivateKey.prototype.toPublicKey`)\n- ECDSA signing (`ECPrivateKey.prototype.sign`)\n- ECDSA verification (`ECPublicKey.prototype.verify`)\n- ECDH key agreement (`ECPrivateKey.prototype.computeSecret`)\n\nIn the first three cases, the points being evaluated are generated randomly, so an attack could only arise due to a bad value being randomly selected (as noted above, with probability roughly `2^{-20}`).  In the latter two cases, the points being evaluated are provided from outside the library, and thus potentially by attackers.\n\n### Patches\n\n_Has the problem been patched? What versions should users upgrade to?_\n\n### Workarounds\n\nSince this issue is only present in the \"fallback\" crypto implementation, it can be avoided by ensuring that either WebCrypto or the Node `crypto` module is available in the JS environment where `node-jose` is being run.\n\n### References\n\n- [Barrett reduction on Wikipedia](https://en.wikipedia.org/wiki/Barrett_reduction)\n\n### For more information\n\nIf you have any questions or comments about this advisory:\n* Open an issue in [cisco/node-jose](https://github.com/cisco/node-jose/issues)\n* Email [Cisco open source security](mailto:oss-security@cisco.com)\n\n### Credits\n\n- Research and disclosure: BlackBerry\n- Fix implementation: [Richard Barnes (@bifurcation)](https://github.com/bifurcation)\n- Release engineering: [Stephen Augustus (@justaugustus)](https://github.com/justaugustus)\n", "methods": ["Used a vulnerability in the \"fallback\" crypto back-end to trigger a Denial-of-Service (DoS) condition.", "Exploited a possible infinite loop in an internal calculation to cause a Denial-of-Service (DoS) condition.", "Used malicious input to trigger a Denial-of-Service (DoS) condition in ECC operations.", "Exploited the lack of handling of negative results in the `modInverse` function to cause an infinite loop.", "Used the `barrettReduce()` function with negative inputs to cause an infinite loop.", "Exploited the lack of validation of modular operations to always return positive results.", "Used the `modInverse` function to compute the modular inverse of the Z coordinate, which sometimes returns negative results.", "Used the `barrettReduce()` function to reduce the output of the `modInverse` function, which can lead to an infinite loop.", "Exploited the fact that the Barrett reduction algorithm in `node-jose` does not handle negative inputs."]}